<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Storage Engine API: mongo::Locker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link href="mongodb.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="mongodb-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Storage Engine API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmongo_1_1Locker.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmongo_1_1Locker-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mongo::Locker Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for acquiring locks.  
 <a href="classmongo_1_1Locker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="locker_8h_source.html">locker.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mongo::Locker:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmongo_1_1Locker.png" usemap="#mongo::Locker_map" alt=""/>
  <map id="mongo::Locker_map" name="mongo::Locker_map">
<area href="classmongo_1_1LockerImpl.html" alt="mongo::LockerImpl&lt; false &gt;" shape="rect" coords="0,56,224,80"/>
<area href="classmongo_1_1LockerImpl.html" title="Interface for acquiring locks. " alt="mongo::LockerImpl&lt; IsForMMAPV1 &gt;" shape="rect" coords="234,56,458,80"/>
<area href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ..." alt="mongo::LockerNoop" shape="rect" coords="468,56,692,80"/>
<area href="classmongo_1_1LockerForTests.html" alt="mongo::LockerForTests" shape="rect" coords="0,112,224,136"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for acquiring locks. </p>
<p>One of those objects will have to be instantiated for each request (transaction).</p>
<p>Lock/unlock methods must always be called from a single thread. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html">LockerInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information and locking statistics for this instance of the locker.  <a href="structmongo_1_1Locker_1_1LockerInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html" title="LockSnapshot captures the state of all resources that are locked, what modes they&#39;re locked in...">LockSnapshot</a> captures the state of all resources that are locked, what modes they're locked in, and how many times they've been locked in that mode.  <a href="structmongo_1_1Locker_1_1LockSnapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1Locker_1_1OneLock.html">OneLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a single lock acquisition for reporting/serialization purposes.  <a href="structmongo_1_1Locker_1_1OneLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac2bef72f3b29c8a23df4e3e8eba7396b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396b">ClientState</a> { <br />
&#160;&#160;<a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396ba0111dd42dd167087894c4d0540305679">kInactive</a>, 
<a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396ba2bc2ca3b799c4fe6401e6edb3dd29d2e">kActiveReader</a>, 
<a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396ba1c44a0c7b6f988e21362efd31325f71a">kActiveWriter</a>, 
<a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396bad06508796f0cf8cfb5e05df4ad30b2b8">kQueuedReader</a>, 
<br />
&#160;&#160;<a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396ba091e01efc9f2e477c93e26224e5e18a6">kQueuedWriter</a>
<br />
 }<tr class="memdesc:ac2bef72f3b29c8a23df4e3e8eba7396b"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for reporting the number of active and queued reader and writer clients.  <a href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac2bef72f3b29c8a23df4e3e8eba7396b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c5830580247311e1ae6ba55490d860a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a1c5830580247311e1ae6ba55490d860a">~Locker</a> ()</td></tr>
<tr class="separator:a1c5830580247311e1ae6ba55490d860a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27e7f292e2b3d737b8182a0eb3a25cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac27e7f292e2b3d737b8182a0eb3a25cc">isNoop</a> () const</td></tr>
<tr class="memdesc:ac27e7f292e2b3d737b8182a0eb3a25cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an instance of <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a>.  <a href="#ac27e7f292e2b3d737b8182a0eb3a25cc">More...</a><br /></td></tr>
<tr class="separator:ac27e7f292e2b3d737b8182a0eb3a25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ca7b0475c0aab5ae4a3d876a2414db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396b">ClientState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a66ca7b0475c0aab5ae4a3d876a2414db">getClientState</a> () const =0</td></tr>
<tr class="memdesc:a66ca7b0475c0aab5ae4a3d876a2414db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether client is holding any locks (active), or is queued on any locks or waiting for a ticket (throttled).  <a href="#a66ca7b0475c0aab5ae4a3d876a2414db">More...</a><br /></td></tr>
<tr class="separator:a66ca7b0475c0aab5ae4a3d876a2414db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5759e316cf858d591f108957942b179"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#ad7b6e5bd2d44b9b4fe9031b23492c38a">LockerId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ab5759e316cf858d591f108957942b179">getId</a> () const =0</td></tr>
<tr class="separator:ab5759e316cf858d591f108957942b179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16c4f59aa603016c9798c371aca4b3"><td class="memItemLeft" align="right" valign="top">virtual stdx::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a5d16c4f59aa603016c9798c371aca4b3">getThreadId</a> () const =0</td></tr>
<tr class="memdesc:a5d16c4f59aa603016c9798c371aca4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a platform-specific thread identifier of the thread which owns the this locker for tracing purposes.  <a href="#a5d16c4f59aa603016c9798c371aca4b3">More...</a><br /></td></tr>
<tr class="separator:a5d16c4f59aa603016c9798c371aca4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0bb10d5d4a0af7054eee135f7a4f3d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a8b0bb10d5d4a0af7054eee135f7a4f3d">updateThreadIdToCurrentThread</a> ()=0</td></tr>
<tr class="memdesc:a8b0bb10d5d4a0af7054eee135f7a4f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates any cached thread id values to represent the current thread.  <a href="#a8b0bb10d5d4a0af7054eee135f7a4f3d">More...</a><br /></td></tr>
<tr class="separator:a8b0bb10d5d4a0af7054eee135f7a4f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49998c9f125b356fa58a03e8459e17d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a49998c9f125b356fa58a03e8459e17d4">unsetThreadId</a> ()=0</td></tr>
<tr class="memdesc:a49998c9f125b356fa58a03e8459e17d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any cached thread id values.  <a href="#a49998c9f125b356fa58a03e8459e17d4">More...</a><br /></td></tr>
<tr class="separator:a49998c9f125b356fa58a03e8459e17d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21d3cf9682ceb71faaf958f7c82c36"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aaa21d3cf9682ceb71faaf958f7c82c36">setSharedLocksShouldTwoPhaseLock</a> (bool sharedLocksShouldTwoPhaseLock)=0</td></tr>
<tr class="memdesc:aaa21d3cf9682ceb71faaf958f7c82c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that shared locks should participate in two-phase locking for this <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> instance.  <a href="#aaa21d3cf9682ceb71faaf958f7c82c36">More...</a><br /></td></tr>
<tr class="separator:aaa21d3cf9682ceb71faaf958f7c82c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae236984c0e83f06f4beab8cec9d29e06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ae236984c0e83f06f4beab8cec9d29e06">setMaxLockTimeout</a> (Milliseconds maxTimeout)=0</td></tr>
<tr class="memdesc:ae236984c0e83f06f4beab8cec9d29e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is useful to ensure that potential deadlocks do not occur.  <a href="#ae236984c0e83f06f4beab8cec9d29e06">More...</a><br /></td></tr>
<tr class="separator:ae236984c0e83f06f4beab8cec9d29e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58100e54f134e14666b32574d1cc55"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aaf58100e54f134e14666b32574d1cc55">hasMaxLockTimeout</a> ()=0</td></tr>
<tr class="memdesc:aaf58100e54f134e14666b32574d1cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> has a maximum lock timeout set.  <a href="#aaf58100e54f134e14666b32574d1cc55">More...</a><br /></td></tr>
<tr class="separator:aaf58100e54f134e14666b32574d1cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239b725701dcfa0f457262b2b186aee2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a239b725701dcfa0f457262b2b186aee2">unsetMaxLockTimeout</a> ()=0</td></tr>
<tr class="memdesc:a239b725701dcfa0f457262b2b186aee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the max lock timeout override set by <a class="el" href="classmongo_1_1Locker.html#ae236984c0e83f06f4beab8cec9d29e06" title="This is useful to ensure that potential deadlocks do not occur. ">setMaxLockTimeout()</a> above.  <a href="#a239b725701dcfa0f457262b2b186aee2">More...</a><br /></td></tr>
<tr class="separator:a239b725701dcfa0f457262b2b186aee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a42be1c14eebcd7e5173101088bc65c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a2a42be1c14eebcd7e5173101088bc65c">lockGlobal</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode)=0</td></tr>
<tr class="memdesc:a2a42be1c14eebcd7e5173101088bc65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be the first method invoked for a particular <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> object.  <a href="#a2a42be1c14eebcd7e5173101088bc65c">More...</a><br /></td></tr>
<tr class="separator:a2a42be1c14eebcd7e5173101088bc65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26abd7d8892aa4b3b589182b3c778ac4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a26abd7d8892aa4b3b589182b3c778ac4">lockGlobal</a> (<a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode)=0</td></tr>
<tr class="separator:a26abd7d8892aa4b3b589182b3c778ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aacb3eff2f28d1201c12199cfdc1076"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a0aacb3eff2f28d1201c12199cfdc1076">lockGlobalBegin</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode, Date_t deadline)=0</td></tr>
<tr class="memdesc:a0aacb3eff2f28d1201c12199cfdc1076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the global lock to be acquired in the specified mode.  <a href="#a0aacb3eff2f28d1201c12199cfdc1076">More...</a><br /></td></tr>
<tr class="separator:a0aacb3eff2f28d1201c12199cfdc1076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5adfd15ad7ecddf7e14de363a80dc03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ad5adfd15ad7ecddf7e14de363a80dc03">lockGlobalBegin</a> (<a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode, Date_t deadline)=0</td></tr>
<tr class="separator:ad5adfd15ad7ecddf7e14de363a80dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ebb980ed7277178a02c0d63070f628"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a37ebb980ed7277178a02c0d63070f628">lockGlobalComplete</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, Date_t deadline)=0</td></tr>
<tr class="memdesc:a37ebb980ed7277178a02c0d63070f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling lockGlobalComplete without an OperationContext does not allow the lock acquisition to be interrupted.  <a href="#a37ebb980ed7277178a02c0d63070f628">More...</a><br /></td></tr>
<tr class="separator:a37ebb980ed7277178a02c0d63070f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0832c3b93147a5eb7a11e835b11522"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a9b0832c3b93147a5eb7a11e835b11522">lockGlobalComplete</a> (Date_t deadline)=0</td></tr>
<tr class="separator:a9b0832c3b93147a5eb7a11e835b11522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783ed88f079cd1ca223e6ce802ffc4c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a783ed88f079cd1ca223e6ce802ffc4c1">lockMMAPV1Flush</a> ()=0</td></tr>
<tr class="memdesc:a783ed88f079cd1ca223e6ce802ffc4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is used only in the MMAP V1 storage engine, otherwise it is a no-op.  <a href="#a783ed88f079cd1ca223e6ce802ffc4c1">More...</a><br /></td></tr>
<tr class="separator:a783ed88f079cd1ca223e6ce802ffc4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21e8c6a9f0b70c286229b1c3710cd45"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac21e8c6a9f0b70c286229b1c3710cd45">unlockGlobal</a> ()=0</td></tr>
<tr class="memdesc:ac21e8c6a9f0b70c286229b1c3710cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference count on the global lock.  <a href="#ac21e8c6a9f0b70c286229b1c3710cd45">More...</a><br /></td></tr>
<tr class="separator:ac21e8c6a9f0b70c286229b1c3710cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c4b395a017ddd958f37e5a96609ad9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a17c4b395a017ddd958f37e5a96609ad9">downgradeGlobalXtoSForMMAPV1</a> ()=0</td></tr>
<tr class="memdesc:a17c4b395a017ddd958f37e5a96609ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is only necessary for the MMAP V1 engine and in particular, the fsyncLock command which needs to first acquire the global lock in X-mode for truncating the journal and then downgrade to S before it blocks.  <a href="#a17c4b395a017ddd958f37e5a96609ad9">More...</a><br /></td></tr>
<tr class="separator:a17c4b395a017ddd958f37e5a96609ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8841f068962cec27d1d94af169e79773"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a8841f068962cec27d1d94af169e79773">beginWriteUnitOfWork</a> ()=0</td></tr>
<tr class="memdesc:a8841f068962cec27d1d94af169e79773"><td class="mdescLeft">&#160;</td><td class="mdescRight">beginWriteUnitOfWork/endWriteUnitOfWork are called at the start and end of WriteUnitOfWorks.  <a href="#a8841f068962cec27d1d94af169e79773">More...</a><br /></td></tr>
<tr class="separator:a8841f068962cec27d1d94af169e79773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fada3707631d104963e19c42e903dd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a4fada3707631d104963e19c42e903dd9">endWriteUnitOfWork</a> ()=0</td></tr>
<tr class="separator:a4fada3707631d104963e19c42e903dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66bf1b8fc7bfbec0682e8b2d992bc53"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ae66bf1b8fc7bfbec0682e8b2d992bc53">inAWriteUnitOfWork</a> () const =0</td></tr>
<tr class="separator:ae66bf1b8fc7bfbec0682e8b2d992bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6921b0cb889468fab89a2519a068abad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a6921b0cb889468fab89a2519a068abad">lock</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, <a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode, Date_t deadline=Date_t::max(), bool checkDeadlock=false)=0</td></tr>
<tr class="memdesc:a6921b0cb889468fab89a2519a068abad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires lock on the specified resource in the specified mode and returns the outcome of the operation.  <a href="#a6921b0cb889468fab89a2519a068abad">More...</a><br /></td></tr>
<tr class="separator:a6921b0cb889468fab89a2519a068abad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c06f9389e114005f6fd3cdee870aeb6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a6c06f9389e114005f6fd3cdee870aeb6">lock</a> (<a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode, Date_t deadline=Date_t::max(), bool checkDeadlock=false)=0</td></tr>
<tr class="memdesc:a6c06f9389e114005f6fd3cdee870aeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling lock without an OperationContext does not allow LOCK_WAITING states to be interrupted.  <a href="#a6c06f9389e114005f6fd3cdee870aeb6">More...</a><br /></td></tr>
<tr class="separator:a6c06f9389e114005f6fd3cdee870aeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a1bcd458d42b5fe709fdc776bd7ce0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aa4a1bcd458d42b5fe709fdc776bd7ce0">downgrade</a> (<a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> newMode)=0</td></tr>
<tr class="memdesc:aa4a1bcd458d42b5fe709fdc776bd7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downgrades the specified resource's lock mode without changing the reference count.  <a href="#aa4a1bcd458d42b5fe709fdc776bd7ce0">More...</a><br /></td></tr>
<tr class="separator:aa4a1bcd458d42b5fe709fdc776bd7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efb8dcdd61205e09ea9a04c14603db4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a0efb8dcdd61205e09ea9a04c14603db4">unlock</a> (<a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId)=0</td></tr>
<tr class="memdesc:a0efb8dcdd61205e09ea9a04c14603db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a lock previously acquired through a lock call.  <a href="#a0efb8dcdd61205e09ea9a04c14603db4">More...</a><br /></td></tr>
<tr class="separator:a0efb8dcdd61205e09ea9a04c14603db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f28579c03a4265408543667d6651ec2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a9f28579c03a4265408543667d6651ec2">getLockMode</a> (<a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId) const =0</td></tr>
<tr class="memdesc:a9f28579c03a4265408543667d6651ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the mode in which a lock is held or checks whether the lock held for a particular resource covers the specified mode.  <a href="#a9f28579c03a4265408543667d6651ec2">More...</a><br /></td></tr>
<tr class="separator:a9f28579c03a4265408543667d6651ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8559abc548eaa478165993d6d76c643b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a8559abc548eaa478165993d6d76c643b">isLockHeldForMode</a> (<a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> resId, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode) const =0</td></tr>
<tr class="separator:a8559abc548eaa478165993d6d76c643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036cb9a09e5b1a4f228c306119eca616"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a036cb9a09e5b1a4f228c306119eca616">isDbLockedForMode</a> (StringData dbName, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode) const =0</td></tr>
<tr class="separator:a036cb9a09e5b1a4f228c306119eca616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85536052d5cb8ec45f336c6f03ada86d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a85536052d5cb8ec45f336c6f03ada86d">isCollectionLockedForMode</a> (StringData <a class="el" href="namespacemongo.html#aa1aad236ca83643ab0718062dd62f4fc">ns</a>, <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mode) const =0</td></tr>
<tr class="separator:a85536052d5cb8ec45f336c6f03ada86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac028513cbbe7b406f3d1ad9a9897a0b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac028513cbbe7b406f3d1ad9a9897a0b7">getWaitingResource</a> () const =0</td></tr>
<tr class="memdesc:ac028513cbbe7b406f3d1ad9a9897a0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resource that this locker is waiting/blocked on (if any).  <a href="#ac028513cbbe7b406f3d1ad9a9897a0b7">More...</a><br /></td></tr>
<tr class="separator:ac028513cbbe7b406f3d1ad9a9897a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9e29a5656ea9b6181824e1a01f6c5e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#abc9e29a5656ea9b6181824e1a01f6c5e">getLockerInfo</a> (<a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html">LockerInfo</a> *lockerInfo) const =0</td></tr>
<tr class="separator:abc9e29a5656ea9b6181824e1a01f6c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37f576922a90a10cabb5b43b9af22ce"><td class="memItemLeft" align="right" valign="top">virtual boost::optional&lt; <a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html">LockerInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac37f576922a90a10cabb5b43b9af22ce">getLockerInfo</a> () const =0</td></tr>
<tr class="memdesc:ac37f576922a90a10cabb5b43b9af22ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns boost::none if this is an instance of <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a>, or a populated <a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html" title="Returns information and locking statistics for this instance of the locker. ">LockerInfo</a> otherwise.  <a href="#ac37f576922a90a10cabb5b43b9af22ce">More...</a><br /></td></tr>
<tr class="separator:ac37f576922a90a10cabb5b43b9af22ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee361b6b57942c06f7276f4e56c1924"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aaee361b6b57942c06f7276f4e56c1924">saveLockStateAndUnlock</a> (<a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> *stateOut)=0</td></tr>
<tr class="memdesc:aaee361b6b57942c06f7276f4e56c1924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all locks held by this transaction, other than RESOURCE_MUTEX locks, and what mode they're held in.  <a href="#aaee361b6b57942c06f7276f4e56c1924">More...</a><br /></td></tr>
<tr class="separator:aaee361b6b57942c06f7276f4e56c1924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4beb55b1ead25e3c3ba5898089d0597"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#af4beb55b1ead25e3c3ba5898089d0597">restoreLockState</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const <a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> &amp;stateToRestore)=0</td></tr>
<tr class="memdesc:af4beb55b1ead25e3c3ba5898089d0597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-locks all locks whose state was stored in 'stateToRestore'.  <a href="#af4beb55b1ead25e3c3ba5898089d0597">More...</a><br /></td></tr>
<tr class="separator:af4beb55b1ead25e3c3ba5898089d0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0c2ae05a8e9790a761251b5ab46d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac1f0c2ae05a8e9790a761251b5ab46d9">restoreLockState</a> (const <a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> &amp;stateToRestore)=0</td></tr>
<tr class="separator:ac1f0c2ae05a8e9790a761251b5ab46d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06c99a1f4137946574e96f6ffc4d677"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#af06c99a1f4137946574e96f6ffc4d677">releaseTicket</a> ()=0</td></tr>
<tr class="memdesc:af06c99a1f4137946574e96f6ffc4d677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ticket associated with the <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a>.  <a href="#af06c99a1f4137946574e96f6ffc4d677">More...</a><br /></td></tr>
<tr class="separator:af06c99a1f4137946574e96f6ffc4d677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1fea527e4d6add6299395924c633e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a6f1fea527e4d6add6299395924c633e6">reacquireTicket</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>)=0</td></tr>
<tr class="memdesc:a6f1fea527e4d6add6299395924c633e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reacquires a ticket for the <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a>.  <a href="#a6f1fea527e4d6add6299395924c633e6">More...</a><br /></td></tr>
<tr class="separator:a6f1fea527e4d6add6299395924c633e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b717f9cea0c297525991d33e8b235e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ae9b717f9cea0c297525991d33e8b235e">dump</a> () const =0</td></tr>
<tr class="separator:ae9b717f9cea0c297525991d33e8b235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af942161dc4ac9ebbc37c0a10fe8fc460"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#af942161dc4ac9ebbc37c0a10fe8fc460">isW</a> () const =0</td></tr>
<tr class="separator:af942161dc4ac9ebbc37c0a10fe8fc460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21214ab42c4475d51efff2f79bf75a33"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a21214ab42c4475d51efff2f79bf75a33">isR</a> () const =0</td></tr>
<tr class="separator:a21214ab42c4475d51efff2f79bf75a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc3c68d207730dff4603b67f56ab0f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a21cc3c68d207730dff4603b67f56ab0f">isLocked</a> () const =0</td></tr>
<tr class="separator:a21cc3c68d207730dff4603b67f56ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b4b7643ddc484609df324e7d201a15"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ac7b4b7643ddc484609df324e7d201a15">isWriteLocked</a> () const =0</td></tr>
<tr class="separator:ac7b4b7643ddc484609df324e7d201a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93923186a25c568fd948fef28a59a7dd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a93923186a25c568fd948fef28a59a7dd">isReadLocked</a> () const =0</td></tr>
<tr class="separator:a93923186a25c568fd948fef28a59a7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9388a42f266d968b226193dff17174"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a1e9388a42f266d968b226193dff17174">isGlobalLockedRecursively</a> ()=0</td></tr>
<tr class="separator:a1e9388a42f266d968b226193dff17174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab083c62d3b5a2a0001d295a13231e75b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ab083c62d3b5a2a0001d295a13231e75b">hasLockPending</a> () const =0</td></tr>
<tr class="memdesc:ab083c62d3b5a2a0001d295a13231e75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending means we are currently trying to get a lock (could be the parallel batch writer lock).  <a href="#ab083c62d3b5a2a0001d295a13231e75b">More...</a><br /></td></tr>
<tr class="separator:ab083c62d3b5a2a0001d295a13231e75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94b9faef1df1a23e353b09bb778f8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ae94b9faef1df1a23e353b09bb778f8cc">setShouldConflictWithSecondaryBatchApplication</a> (bool newValue)</td></tr>
<tr class="memdesc:ae94b9faef1df1a23e353b09bb778f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to false, this opts out of conflicting with replication's use of the ParallelBatchWriterMode lock.  <a href="#ae94b9faef1df1a23e353b09bb778f8cc">More...</a><br /></td></tr>
<tr class="separator:ae94b9faef1df1a23e353b09bb778f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587ef968cd89c5d79e34dee55e444656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a587ef968cd89c5d79e34dee55e444656">shouldConflictWithSecondaryBatchApplication</a> () const</td></tr>
<tr class="separator:a587ef968cd89c5d79e34dee55e444656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa328b64d04622634a7bd87656828d88f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aa328b64d04622634a7bd87656828d88f">setShouldAcquireTicket</a> (bool newValue)</td></tr>
<tr class="memdesc:aa328b64d04622634a7bd87656828d88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to false, this opts out of the ticket mechanism.  <a href="#aa328b64d04622634a7bd87656828d88f">More...</a><br /></td></tr>
<tr class="separator:aa328b64d04622634a7bd87656828d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ed3cacd071f0610e20b59adca08a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a05ed3cacd071f0610e20b59adca08a9b">shouldAcquireTicket</a> () const</td></tr>
<tr class="separator:a05ed3cacd071f0610e20b59adca08a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3068c40167d05e4679c7cc70ab858b34"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a3068c40167d05e4679c7cc70ab858b34">numResourcesToUnlockAtEndUnitOfWorkForTest</a> () const</td></tr>
<tr class="memdesc:a3068c40167d05e4679c7cc70ab858b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is for unit testing only.  <a href="#a3068c40167d05e4679c7cc70ab858b34">More...</a><br /></td></tr>
<tr class="separator:a3068c40167d05e4679c7cc70ab858b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2f2acb3bc1115d2c0b7f7a41640a5b11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a2f2acb3bc1115d2c0b7f7a41640a5b11">setGlobalThrottling</a> (class TicketHolder *reading, class TicketHolder *writing)</td></tr>
<tr class="memdesc:a2f2acb3bc1115d2c0b7f7a41640a5b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require global lock attempts to obtain tickets from 'reading' (for MODE_S and MODE_IS), and from 'writing' (for MODE_IX), which must have static lifetimes.  <a href="#a2f2acb3bc1115d2c0b7f7a41640a5b11">More...</a><br /></td></tr>
<tr class="separator:a2f2acb3bc1115d2c0b7f7a41640a5b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aca0763e95e85e3ed6972ef6cb245fdb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aca0763e95e85e3ed6972ef6cb245fdb3">Locker</a> ()</td></tr>
<tr class="separator:aca0763e95e85e3ed6972ef6cb245fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5e907d7c1a238d90330768e7444430f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a5e907d7c1a238d90330768e7444430f4">_uninterruptibleLocksRequested</a> = 0</td></tr>
<tr class="memdesc:a5e907d7c1a238d90330768e7444430f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of callers that are guarding from lock interruptions.  <a href="#a5e907d7c1a238d90330768e7444430f4">More...</a><br /></td></tr>
<tr class="separator:a5e907d7c1a238d90330768e7444430f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43ef3425b55d3cc48fb2e1d3f680379"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#ae43ef3425b55d3cc48fb2e1d3f680379">_numResourcesToUnlockAtEndUnitOfWork</a> = 0</td></tr>
<tr class="memdesc:ae43ef3425b55d3cc48fb2e1d3f680379"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of LockRequests to unlock at the end of this WUOW.  <a href="#ae43ef3425b55d3cc48fb2e1d3f680379">More...</a><br /></td></tr>
<tr class="separator:ae43ef3425b55d3cc48fb2e1d3f680379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a145caa952acc31fea2b96a02ecb88ff7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a145caa952acc31fea2b96a02ecb88ff7">MONGO_DISALLOW_COPYING</a> (<a class="el" href="classmongo_1_1Locker.html">Locker</a>)</td></tr>
<tr class="separator:a145caa952acc31fea2b96a02ecb88ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaccad85edd0064fc9bc9373d5e412747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#aaccad85edd0064fc9bc9373d5e412747">_shouldConflictWithSecondaryBatchApplication</a> = true</td></tr>
<tr class="separator:aaccad85edd0064fc9bc9373d5e412747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8247b0fc9d4d1682734091625fc03ca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a8247b0fc9d4d1682734091625fc03ca7">_shouldAcquireTicket</a> = true</td></tr>
<tr class="separator:a8247b0fc9d4d1682734091625fc03ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2a95db179510f267b31433b50a2ff590"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1Locker.html#a2a95db179510f267b31433b50a2ff590">UninterruptibleLockGuard</a></td></tr>
<tr class="separator:a2a95db179510f267b31433b50a2ff590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac2bef72f3b29c8a23df4e3e8eba7396b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bef72f3b29c8a23df4e3e8eba7396b">&#9670;&nbsp;</a></span>ClientState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396b">mongo::Locker::ClientState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>State for reporting the number of active and queued reader and writer clients. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac2bef72f3b29c8a23df4e3e8eba7396ba0111dd42dd167087894c4d0540305679"></a>kInactive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2bef72f3b29c8a23df4e3e8eba7396ba2bc2ca3b799c4fe6401e6edb3dd29d2e"></a>kActiveReader&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2bef72f3b29c8a23df4e3e8eba7396ba1c44a0c7b6f988e21362efd31325f71a"></a>kActiveWriter&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2bef72f3b29c8a23df4e3e8eba7396bad06508796f0cf8cfb5e05df4ad30b2b8"></a>kQueuedReader&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac2bef72f3b29c8a23df4e3e8eba7396ba091e01efc9f2e477c93e26224e5e18a6"></a>kQueuedWriter&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1c5830580247311e1ae6ba55490d860a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5830580247311e1ae6ba55490d860a">&#9670;&nbsp;</a></span>~Locker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mongo::Locker::~Locker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca0763e95e85e3ed6972ef6cb245fdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0763e95e85e3ed6972ef6cb245fdb3">&#9670;&nbsp;</a></span>Locker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mongo::Locker::Locker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8841f068962cec27d1d94af169e79773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8841f068962cec27d1d94af169e79773">&#9670;&nbsp;</a></span>beginWriteUnitOfWork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::beginWriteUnitOfWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>beginWriteUnitOfWork/endWriteUnitOfWork are called at the start and end of WriteUnitOfWorks. </p>
<p>They can be used to implement two-phase locking. Each call to begin should be matched with an eventual call to end.</p>
<p>endWriteUnitOfWork, if not called in a nested WUOW, will release all two-phase locking held lock resources. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#acc909e1c84dcf282cac6a782a20563e5">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#acc909e1c84dcf282cac6a782a20563e5">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#afeacfb5b467c531872f9ee0e60933886">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="aa4a1bcd458d42b5fe709fdc776bd7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a1bcd458d42b5fe709fdc776bd7ce0">&#9670;&nbsp;</a></span>downgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::downgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>newMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downgrades the specified resource's lock mode without changing the reference count. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a1e30da00a25fc357ccebbe721b538059">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a1e30da00a25fc357ccebbe721b538059">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#af5e825bc35da2c0629705456416316ab">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a17c4b395a017ddd958f37e5a96609ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c4b395a017ddd958f37e5a96609ad9">&#9670;&nbsp;</a></span>downgradeGlobalXtoSForMMAPV1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::downgradeGlobalXtoSForMMAPV1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is only necessary for the MMAP V1 engine and in particular, the fsyncLock command which needs to first acquire the global lock in X-mode for truncating the journal and then downgrade to S before it blocks. </p>
<p>The downgrade is necessary in order to be nice and not block readers while under fsyncLock. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a693562a0483f6793cf6ebd36122595f2">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a693562a0483f6793cf6ebd36122595f2">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a041c4c80796e7dd3be6e74ac94b0f5b1">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ae9b717f9cea0c297525991d33e8b235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b717f9cea0c297525991d33e8b235e">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#abec0e7ada9c31a9e4f8d35d71204dc4f">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#abec0e7ada9c31a9e4f8d35d71204dc4f">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a7984d616a7d2d7e5a3f3ea094936b8f6">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a4fada3707631d104963e19c42e903dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fada3707631d104963e19c42e903dd9">&#9670;&nbsp;</a></span>endWriteUnitOfWork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::endWriteUnitOfWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a16a887a4a0e45f4ea5a16abd9aa118ba">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a16a887a4a0e45f4ea5a16abd9aa118ba">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a824434d604207c89589d673e5b17e002">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a66ca7b0475c0aab5ae4a3d876a2414db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ca7b0475c0aab5ae4a3d876a2414db">&#9670;&nbsp;</a></span>getClientState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmongo_1_1Locker.html#ac2bef72f3b29c8a23df4e3e8eba7396b">ClientState</a> mongo::Locker::getClientState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether client is holding any locks (active), or is queued on any locks or waiting for a ticket (throttled). </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a898868ff0b189458e9ccf6e7912b1c7c">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a898868ff0b189458e9ccf6e7912b1c7c">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a39b3ddaf8391882ef0f14a4492a10efc">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ab5759e316cf858d591f108957942b179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5759e316cf858d591f108957942b179">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#ad7b6e5bd2d44b9b4fe9031b23492c38a">LockerId</a> mongo::Locker::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a25e6346558e7722752a6685cf0b5165a">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a25e6346558e7722752a6685cf0b5165a">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a454c4e29f5ab5548df51e4c8b2d5af48">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="abc9e29a5656ea9b6181824e1a01f6c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9e29a5656ea9b6181824e1a01f6c5e">&#9670;&nbsp;</a></span>getLockerInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::getLockerInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html">LockerInfo</a> *&#160;</td>
          <td class="paramname"><em>lockerInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a77d5334cecfcf5da4ffb1ece721bf43b">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a77d5334cecfcf5da4ffb1ece721bf43b">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#aa8edfa6da84a705e3fc98b06ad1bd2e1">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac37f576922a90a10cabb5b43b9af22ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37f576922a90a10cabb5b43b9af22ce">&#9670;&nbsp;</a></span>getLockerInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::optional&lt;<a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html">LockerInfo</a>&gt; mongo::Locker::getLockerInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns boost::none if this is an instance of <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a>, or a populated <a class="el" href="structmongo_1_1Locker_1_1LockerInfo.html" title="Returns information and locking statistics for this instance of the locker. ">LockerInfo</a> otherwise. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a4b048b62e8671cdc39601db58701c337">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a4b048b62e8671cdc39601db58701c337">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a0abf290e966f201c5042bcb2d710d237">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a9f28579c03a4265408543667d6651ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f28579c03a4265408543667d6651ec2">&#9670;&nbsp;</a></span>getLockMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a> mongo::Locker::getLockMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the mode in which a lock is held or checks whether the lock held for a particular resource covers the specified mode. </p>
<p>For example isLockHeldForMode will return true for MODE_S, if MODE_X is already held, because MODE_X covers MODE_S. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#acaf2ba4e812da09ce1c45ed37d738565">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#acaf2ba4e812da09ce1c45ed37d738565">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a22fb7e98cc6689c5547d869b10d98be3">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a5d16c4f59aa603016c9798c371aca4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d16c4f59aa603016c9798c371aca4b3">&#9670;&nbsp;</a></span>getThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual stdx::thread::id mongo::Locker::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a platform-specific thread identifier of the thread which owns the this locker for tracing purposes. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a0a59b50fbec6af980488c6964f292e60">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a0a59b50fbec6af980488c6964f292e60">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ad7f249b8fd9f3445d028f2ca223e2e82">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac028513cbbe7b406f3d1ad9a9897a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac028513cbbe7b406f3d1ad9a9897a0b7">&#9670;&nbsp;</a></span>getWaitingResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a> mongo::Locker::getWaitingResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the resource that this locker is waiting/blocked on (if any). </p>
<p>If the locker is not waiting for a resource the returned value will be invalid (isValid() == false). </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a4ed094dda7db7d147942b3842a2bdcc7">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a4ed094dda7db7d147942b3842a2bdcc7">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a828bdd0dc0fadadfdc78c8ae3a128143">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ab083c62d3b5a2a0001d295a13231e75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab083c62d3b5a2a0001d295a13231e75b">&#9670;&nbsp;</a></span>hasLockPending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::hasLockPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pending means we are currently trying to get a lock (could be the parallel batch writer lock). </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a518883ab6c32341fa7003fd3a84eda2c">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a518883ab6c32341fa7003fd3a84eda2c">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4f98a54550838ef40fa6ed1a4b711dbd">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="aaf58100e54f134e14666b32574d1cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf58100e54f134e14666b32574d1cc55">&#9670;&nbsp;</a></span>hasMaxLockTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::hasMaxLockTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> has a maximum lock timeout set. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a59bbba14265db2373e5ca7e67f87b7cb">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a59bbba14265db2373e5ca7e67f87b7cb">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a7545cf99ea289a92e7a158c993fa7c22">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ae66bf1b8fc7bfbec0682e8b2d992bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66bf1b8fc7bfbec0682e8b2d992bc53">&#9670;&nbsp;</a></span>inAWriteUnitOfWork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::inAWriteUnitOfWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ad1b8fa7cd5e95d0e7082d8593ff296c3">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ad1b8fa7cd5e95d0e7082d8593ff296c3">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a725743399ebcda47ea443534875ae57c">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a85536052d5cb8ec45f336c6f03ada86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85536052d5cb8ec45f336c6f03ada86d">&#9670;&nbsp;</a></span>isCollectionLockedForMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isCollectionLockedForMode </td>
          <td>(</td>
          <td class="paramtype">StringData&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a6649874f62a8cdd5221f09163c00d3f2">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a6649874f62a8cdd5221f09163c00d3f2">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#acf96dc8cbad225caf9464c450af768de">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a036cb9a09e5b1a4f228c306119eca616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036cb9a09e5b1a4f228c306119eca616">&#9670;&nbsp;</a></span>isDbLockedForMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isDbLockedForMode </td>
          <td>(</td>
          <td class="paramtype">StringData&#160;</td>
          <td class="paramname"><em>dbName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#aaa4a875748a0b9898023cb45c6a7446d">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#aaa4a875748a0b9898023cb45c6a7446d">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4099aea86ecb8bdab1ba29e3c21324ed">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a1e9388a42f266d968b226193dff17174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9388a42f266d968b226193dff17174">&#9670;&nbsp;</a></span>isGlobalLockedRecursively()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isGlobalLockedRecursively </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#aad1d0a75cbb1ab91c34231743a364c92">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#aad1d0a75cbb1ab91c34231743a364c92">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a1ba09b8cce10ffe29a1705f12ae1f6b9">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a21cc3c68d207730dff4603b67f56ab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc3c68d207730dff4603b67f56ab0f">&#9670;&nbsp;</a></span>isLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a6a2a82f40c48e229e981ed0f050a7230">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a6a2a82f40c48e229e981ed0f050a7230">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#aa8dc09b62e739b136522d84ffb76aa4b">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a8559abc548eaa478165993d6d76c643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8559abc548eaa478165993d6d76c643b">&#9670;&nbsp;</a></span>isLockHeldForMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isLockHeldForMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a56561c28ec9aa2ebc25295e7fc36a5b7">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a56561c28ec9aa2ebc25295e7fc36a5b7">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a9120412fa9da048fadb0e50fad66e95e">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac27e7f292e2b3d737b8182a0eb3a25cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27e7f292e2b3d737b8182a0eb3a25cc">&#9670;&nbsp;</a></span>isNoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isNoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is an instance of <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a>. </p>
<p>Because <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a> doesn't implement many methods, some users may need to check this first to find out what is safe to call. <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a> is only used in unittests and for a brief period at startup, so you can assume you hold the equivalent of a MODE_X lock when using it.</p>
<p>TODO get rid of this once we kill <a class="el" href="classmongo_1_1LockerNoop.html" title="Locker, which cannot be used to lock/unlock resources and just returns true for checks for whether a ...">LockerNoop</a>. </p>

<p>Reimplemented in <a class="el" href="classmongo_1_1LockerNoop.html#aa37ef81c73437f177165d39ddd293b13">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a21214ab42c4475d51efff2f79bf75a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21214ab42c4475d51efff2f79bf75a33">&#9670;&nbsp;</a></span>isR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a1f955d0c82b3a78a94619d0b27dc1044">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a1f955d0c82b3a78a94619d0b27dc1044">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4106cf33d4efa262d351c310ad77e538">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a93923186a25c568fd948fef28a59a7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93923186a25c568fd948fef28a59a7dd">&#9670;&nbsp;</a></span>isReadLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isReadLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#abae09f8c61783861f7a20c11ce07bd0e">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#abae09f8c61783861f7a20c11ce07bd0e">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ad0d6597590fd7ed965590d12b5fe5960">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="af942161dc4ac9ebbc37c0a10fe8fc460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af942161dc4ac9ebbc37c0a10fe8fc460">&#9670;&nbsp;</a></span>isW()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ab66822b7ada973d946b55ee119b30943">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ab66822b7ada973d946b55ee119b30943">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a0fc2e03aa0ffde6d17940b3066aa8404">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac7b4b7643ddc484609df324e7d201a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b4b7643ddc484609df324e7d201a15">&#9670;&nbsp;</a></span>isWriteLocked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::isWriteLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a96c45bad6c72299e80ae3c1f83f11b76">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a96c45bad6c72299e80ae3c1f83f11b76">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a274c32cdb1ec6d274ed6a31ef91534bf">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a6921b0cb889468fab89a2519a068abad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6921b0cb889468fab89a2519a068abad">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lock </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>Date_t::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkDeadlock</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires lock on the specified resource in the specified mode and returns the outcome of the operation. </p>
<p>See the details for LockResult for more information on what the different results mean.</p>
<p>Each successful acquisition of a lock on a given resource increments the reference count of the lock. Therefore, each call, which returns LOCK_OK must be matched with a corresponding call to unlock.</p>
<p>If setLockTimeoutMillis has been called, then a lock request with a Date_t::max() deadline may throw a LockTimeout error. See <a class="el" href="classmongo_1_1Locker.html#ae236984c0e83f06f4beab8cec9d29e06" title="This is useful to ensure that potential deadlocks do not occur. ">setMaxLockTimeout()</a> above for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opCtx</td><td>If provided, will be used to interrupt a LOCK_WAITING state. </td></tr>
    <tr><td class="paramname">resId</td><td>Id of the resource to be locked. </td></tr>
    <tr><td class="paramname">mode</td><td>Mode in which the resource should be locked. <a class="el" href="classmongo_1_1Lock.html">Lock</a> upgrades are allowed. </td></tr>
    <tr><td class="paramname">deadline</td><td>How long to wait for the lock to be granted, before returning LOCK_TIMEOUT. This parameter defaults to an infinite deadline. If Milliseconds(0) is passed, the request will return immediately, if the request could not be granted right away. </td></tr>
    <tr><td class="paramname">checkDeadlock</td><td>Whether to enable deadlock detection for this acquisition. This parameter is put in place until we can handle deadlocks at all places, which acquire locks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All LockResults except for LOCK_WAITING, because it blocks. </dd></dl>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a179b77e68f2b296ecdc63136c3ba8ab6">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a179b77e68f2b296ecdc63136c3ba8ab6">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a6351b468a4b9bb3a9ef18a65c70c6d75">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a6c06f9389e114005f6fd3cdee870aeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c06f9389e114005f6fd3cdee870aeb6">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em> = <code>Date_t::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkDeadlock</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling lock without an OperationContext does not allow LOCK_WAITING states to be interrupted. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a4e33cc065fb13bd828aadcf6f12f9edf">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a4e33cc065fb13bd828aadcf6f12f9edf">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a3534ee1aa58e6602f03c7e8d69f6c122">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a2a42be1c14eebcd7e5173101088bc65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a42be1c14eebcd7e5173101088bc65c">&#9670;&nbsp;</a></span>lockGlobal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobal </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This should be the first method invoked for a particular <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> object. </p>
<p>It acquires the Global lock in the specified mode and effectively indicates the mode of the operation. This is what the lock modes on the global lock mean:</p>
<p>IX - Regular write operation IS - Regular read operation S - Stops all <em>write</em> activity. Used for administrative operations (repl, etc). X - Stops all activity. Used for administrative operations (repl state changes, shutdown, etc).</p>
<p>This method can be called recursively, but each call to lockGlobal must be accompanied by a call to unlockGlobal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opCtx</td><td>OperationContext used to interrupt the lock waiting, if provided. </td></tr>
    <tr><td class="paramname">mode</td><td>Mode in which the global lock should be acquired. Also indicates the intent of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LOCK_OK, if the global lock (and the flush lock, for the MMAP V1 engine) were acquired within the specified time bound. Otherwise, the respective failure code and neither lock will be acquired. </dd></dl>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ae6095035a20069df9f57b436e9e4382d">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ae6095035a20069df9f57b436e9e4382d">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ab73e30c2396d2945a2a7d2ac3f8c9e32">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a26abd7d8892aa4b3b589182b3c778ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26abd7d8892aa4b3b589182b3c778ac4">&#9670;&nbsp;</a></span>lockGlobal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a6e9095ec95229b788dd0450e92197a55">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a6e9095ec95229b788dd0450e92197a55">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a419ddda53d9b46a441307691d43a91fa">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a0aacb3eff2f28d1201c12199cfdc1076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aacb3eff2f28d1201c12199cfdc1076">&#9670;&nbsp;</a></span>lockGlobalBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobalBegin </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the global lock to be acquired in the specified mode. </p>
<p>See the comments for lockBegin/Complete for more information on the semantics. The deadline indicates the absolute time point when this lock acquisition will time out, if not yet granted. The lockGlobalBegin method has a deadline for use with the TicketHolder, if there is one. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#abec4edae17a1540d1b8a8d8287e467ae">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#abec4edae17a1540d1b8a8d8287e467ae">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a7718afa07b99b3b1183e2d6f0527f028">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ad5adfd15ad7ecddf7e14de363a80dc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5adfd15ad7ecddf7e14de363a80dc03">&#9670;&nbsp;</a></span>lockGlobalBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobalBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a9a3ebc0a91ee78ba95fc1ef18a948a2b">LockMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a09438e62404c4eec04c5aa4419b9608d">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a09438e62404c4eec04c5aa4419b9608d">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#af7dc88d9b1cc2fce6e6c520f297bbbb2">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a37ebb980ed7277178a02c0d63070f628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ebb980ed7277178a02c0d63070f628">&#9670;&nbsp;</a></span>lockGlobalComplete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobalComplete </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calling lockGlobalComplete without an OperationContext does not allow the lock acquisition to be interrupted. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a223336d1f191dea8118b5909a9d0d626">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a223336d1f191dea8118b5909a9d0d626">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#aa32d03ec73ec40910819ab6d2190a0e6">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a9b0832c3b93147a5eb7a11e835b11522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0832c3b93147a5eb7a11e835b11522">&#9670;&nbsp;</a></span>lockGlobalComplete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#af54347edd3ad8dc00c6c27e0816e2dea">LockResult</a> mongo::Locker::lockGlobalComplete </td>
          <td>(</td>
          <td class="paramtype">Date_t&#160;</td>
          <td class="paramname"><em>deadline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a425b455e0f8f4b8b32ecb0e88f58eff0">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a425b455e0f8f4b8b32ecb0e88f58eff0">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4242f7a3be627f4137de4a8a0e47c2c0">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a783ed88f079cd1ca223e6ce802ffc4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783ed88f079cd1ca223e6ce802ffc4c1">&#9670;&nbsp;</a></span>lockMMAPV1Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::lockMMAPV1Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is used only in the MMAP V1 storage engine, otherwise it is a no-op. </p>
<p>See the comments in the implementation for more details on how MMAP V1 journaling works. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a05d6542e55d24e316cd59c4d0aabe612">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a05d6542e55d24e316cd59c4d0aabe612">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a436f8d360759250afa4a7084242bc514">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a145caa952acc31fea2b96a02ecb88ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145caa952acc31fea2b96a02ecb88ff7">&#9670;&nbsp;</a></span>MONGO_DISALLOW_COPYING()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mongo::Locker::MONGO_DISALLOW_COPYING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1Locker.html">Locker</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3068c40167d05e4679c7cc70ab858b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3068c40167d05e4679c7cc70ab858b34">&#9670;&nbsp;</a></span>numResourcesToUnlockAtEndUnitOfWorkForTest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mongo::Locker::numResourcesToUnlockAtEndUnitOfWorkForTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is for unit testing only. </p>

</div>
</div>
<a id="a6f1fea527e4d6add6299395924c633e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1fea527e4d6add6299395924c633e6">&#9670;&nbsp;</a></span>reacquireTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::reacquireTicket </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reacquires a ticket for the <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a>. </p>
<p>This must only be called after <a class="el" href="classmongo_1_1Locker.html#af06c99a1f4137946574e96f6ffc4d677" title="Releases the ticket associated with the Locker. ">releaseTicket()</a>. It restores the ticket under its previous LockMode. An OperationContext is required to interrupt the ticket acquisition to prevent deadlocks. A dead lock is possible when a ticket is reacquired while holding a lock. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ac7e78b09f64b0825e9c468fab9724af5">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ac7e78b09f64b0825e9c468fab9724af5">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a919ef9e9e2e94ae83bf7d242e6d38c8e">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="af06c99a1f4137946574e96f6ffc4d677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06c99a1f4137946574e96f6ffc4d677">&#9670;&nbsp;</a></span>releaseTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::releaseTicket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the ticket associated with the <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a>. </p>
<p>This allows locks to be held without contributing to reader/writer throttling. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a744aefc2e5818ef096e1208119cb9332">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a744aefc2e5818ef096e1208119cb9332">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#aa4a9bde7c2d66e9b5dfe894ca461c2d3">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="af4beb55b1ead25e3c3ba5898089d0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4beb55b1ead25e3c3ba5898089d0597">&#9670;&nbsp;</a></span>restoreLockState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::restoreLockState </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>stateToRestore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-locks all locks whose state was stored in 'stateToRestore'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opCtx</td><td>An operation context that enables the restoration to be interrupted. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a7c18ee5ac579058ce8db79f501724992">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a7c18ee5ac579058ce8db79f501724992">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a3b38dd6bc52f9c7411e61bc16be4b45f">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac1f0c2ae05a8e9790a761251b5ab46d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f0c2ae05a8e9790a761251b5ab46d9">&#9670;&nbsp;</a></span>restoreLockState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::restoreLockState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> &amp;&#160;</td>
          <td class="paramname"><em>stateToRestore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a854ebed7d0615200c1cb0c6138cbe39b">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a854ebed7d0615200c1cb0c6138cbe39b">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ad43ee2edd16ec9e44e9fce3b730cd616">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="aaee361b6b57942c06f7276f4e56c1924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee361b6b57942c06f7276f4e56c1924">&#9670;&nbsp;</a></span>saveLockStateAndUnlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::saveLockStateAndUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmongo_1_1Locker_1_1LockSnapshot.html">LockSnapshot</a> *&#160;</td>
          <td class="paramname"><em>stateOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves all locks held by this transaction, other than RESOURCE_MUTEX locks, and what mode they're held in. </p>
<p>Stores these locks in 'stateOut', destroying any previous state. Unlocks all locks held by this transaction. This functionality is used for yielding, which is voluntary/cooperative lock release and reacquisition in order to allow for interleaving of otherwise conflicting long-running operations.</p>
<p>This functionality is also used for releasing locks on databases and collections when cursors are dormant and waiting for a getMore request.</p>
<p>Returns true if locks are released. It is expected that restoreLockerImpl will be called in the future.</p>
<p>Returns false if locks are not released. restoreLockState(...) does not need to be called in this case. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a57f74c5fb2465b912fe1021e1228b130">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a57f74c5fb2465b912fe1021e1228b130">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ab5b94f8550fd24c5e42e8f7193a75e09">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a2f2acb3bc1115d2c0b7f7a41640a5b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2acb3bc1115d2c0b7f7a41640a5b11">&#9670;&nbsp;</a></span>setGlobalThrottling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::setGlobalThrottling </td>
          <td>(</td>
          <td class="paramtype">class TicketHolder *&#160;</td>
          <td class="paramname"><em>reading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class TicketHolder *&#160;</td>
          <td class="paramname"><em>writing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Require global lock attempts to obtain tickets from 'reading' (for MODE_S and MODE_IS), and from 'writing' (for MODE_IX), which must have static lifetimes. </p>
<p>There is no throttling for MODE_X, as there can only ever be a single locker using this mode. The throttling is intended to defend against arge drops in throughput under high load due to too much concurrency. </p>

</div>
</div>
<a id="ae236984c0e83f06f4beab8cec9d29e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae236984c0e83f06f4beab8cec9d29e06">&#9670;&nbsp;</a></span>setMaxLockTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::setMaxLockTimeout </td>
          <td>(</td>
          <td class="paramtype">Milliseconds&#160;</td>
          <td class="paramname"><em>maxTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is useful to ensure that potential deadlocks do not occur. </p>
<p>Overrides provided timeouts in lock requests with 'maxTimeout' if the provided timeout is greater. Basically, no lock acquisition will take longer than 'maxTimeout'.</p>
<p>If an <a class="el" href="classmongo_1_1UninterruptibleLockGuard.html" title="This class prevents lock acquisitions from being interrupted when it is in scope. ...">UninterruptibleLockGuard</a> is set during a lock request, the max timeout override will be ignored.</p>
<p>Future lock requests may throw LockTimeout errors if a lock request provides a Date_t::max() deadline and 'maxTimeout' is reached. Presumably these callers do not expect to handle lock acquisition failure, so this is done to ensure the caller does not proceed as if the lock were successfully acquired. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a0cb45a28cabdbca62b76bfc7ca83677d">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a0cb45a28cabdbca62b76bfc7ca83677d">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a456f3095a30523c4ab4cc1364ba5e21a">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="aaa21d3cf9682ceb71faaf958f7c82c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa21d3cf9682ceb71faaf958f7c82c36">&#9670;&nbsp;</a></span>setSharedLocksShouldTwoPhaseLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::setSharedLocksShouldTwoPhaseLock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sharedLocksShouldTwoPhaseLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate that shared locks should participate in two-phase locking for this <a class="el" href="classmongo_1_1Locker.html" title="Interface for acquiring locks. ">Locker</a> instance. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a0d4e14201a4ac315b85498102fe55002">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a0d4e14201a4ac315b85498102fe55002">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#ab622ce97be2a8f7bef04435d833baf46">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="aa328b64d04622634a7bd87656828d88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa328b64d04622634a7bd87656828d88f">&#9670;&nbsp;</a></span>setShouldAcquireTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::setShouldAcquireTicket </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to false, this opts out of the ticket mechanism. </p>
<p>This should be used sparingly for special purpose threads, such as FTDC. </p>

</div>
</div>
<a id="ae94b9faef1df1a23e353b09bb778f8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94b9faef1df1a23e353b09bb778f8cc">&#9670;&nbsp;</a></span>setShouldConflictWithSecondaryBatchApplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::setShouldConflictWithSecondaryBatchApplication </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to false, this opts out of conflicting with replication's use of the ParallelBatchWriterMode lock. </p>
<p>Code that opts-out must be ok with seeing an inconsistent view of data because within a batch, secondaries apply operations in a different order than on the primary. User operations should <em>never</em> opt out. </p>

</div>
</div>
<a id="a05ed3cacd071f0610e20b59adca08a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ed3cacd071f0610e20b59adca08a9b">&#9670;&nbsp;</a></span>shouldAcquireTicket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::Locker::shouldAcquireTicket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a587ef968cd89c5d79e34dee55e444656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587ef968cd89c5d79e34dee55e444656">&#9670;&nbsp;</a></span>shouldConflictWithSecondaryBatchApplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::Locker::shouldConflictWithSecondaryBatchApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0efb8dcdd61205e09ea9a04c14603db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efb8dcdd61205e09ea9a04c14603db4">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ResourceId.html">ResourceId</a>&#160;</td>
          <td class="paramname"><em>resId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a lock previously acquired through a lock call. </p>
<p>It is an error to try to release lock which has not been previously acquired (invariant violation).</p>
<dl class="section return"><dt>Returns</dt><dd>true if the lock was actually released; false if only the reference count was decremented, but the lock is still held. </dd></dl>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ab608ef47a3fedf3e5e80e3a593465653">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ab608ef47a3fedf3e5e80e3a593465653">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#afbfd10c587ea33cb743494d5210a14bf">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="ac21e8c6a9f0b70c286229b1c3710cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21e8c6a9f0b70c286229b1c3710cd45">&#9670;&nbsp;</a></span>unlockGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::Locker::unlockGlobal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the reference count on the global lock. </p>
<p>If the reference count on the global lock hits zero, the transaction is over, and unlockGlobal unlocks all other locks except for RESOURCE_MUTEX locks.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is the last endTransaction call (i.e., the global lock was released); false if there are still references on the global lock. This value should not be relied on and is only used for assertion purposes.</dd>
<dd>
false if the global lock is still held. </dd></dl>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#a25471a9785fd95682cf06bc83c744b6e">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#a25471a9785fd95682cf06bc83c744b6e">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#acfc5cfb2de455c6b6ef9f167c00686a2">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a239b725701dcfa0f457262b2b186aee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239b725701dcfa0f457262b2b186aee2">&#9670;&nbsp;</a></span>unsetMaxLockTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::unsetMaxLockTimeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the max lock timeout override set by <a class="el" href="classmongo_1_1Locker.html#ae236984c0e83f06f4beab8cec9d29e06" title="This is useful to ensure that potential deadlocks do not occur. ">setMaxLockTimeout()</a> above. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#aff3132177d05cf4cb7352ea28bacffd9">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#aff3132177d05cf4cb7352ea28bacffd9">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4cd75d9e33ffdb45d0dd87b7327d578b">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a49998c9f125b356fa58a03e8459e17d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49998c9f125b356fa58a03e8459e17d4">&#9670;&nbsp;</a></span>unsetThreadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::unsetThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any cached thread id values. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#af832a6997efa8507927e1acdbc52266b">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#af832a6997efa8507927e1acdbc52266b">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a4a6377faa94436a6aef3bfb2a5cdbdb1">mongo::LockerNoop</a>.</p>

</div>
</div>
<a id="a8b0bb10d5d4a0af7054eee135f7a4f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0bb10d5d4a0af7054eee135f7a4f3d">&#9670;&nbsp;</a></span>updateThreadIdToCurrentThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::Locker::updateThreadIdToCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates any cached thread id values to represent the current thread. </p>

<p>Implemented in <a class="el" href="classmongo_1_1LockerImpl.html#ad17c45d74aedec5a2a298808f24665cb">mongo::LockerImpl&lt; IsForMMAPV1 &gt;</a>, <a class="el" href="classmongo_1_1LockerImpl.html#ad17c45d74aedec5a2a298808f24665cb">mongo::LockerImpl&lt; false &gt;</a>, and <a class="el" href="classmongo_1_1LockerNoop.html#a93cc1cff8bf3eebff336ba86503b2032">mongo::LockerNoop</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2a95db179510f267b31433b50a2ff590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a95db179510f267b31433b50a2ff590">&#9670;&nbsp;</a></span>UninterruptibleLockGuard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmongo_1_1UninterruptibleLockGuard.html">UninterruptibleLockGuard</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae43ef3425b55d3cc48fb2e1d3f680379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43ef3425b55d3cc48fb2e1d3f680379">&#9670;&nbsp;</a></span>_numResourcesToUnlockAtEndUnitOfWork</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mongo::Locker::_numResourcesToUnlockAtEndUnitOfWork = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of LockRequests to unlock at the end of this WUOW. </p>
<p>This is used for locks participating in two-phase locking. </p>

</div>
</div>
<a id="a8247b0fc9d4d1682734091625fc03ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8247b0fc9d4d1682734091625fc03ca7">&#9670;&nbsp;</a></span>_shouldAcquireTicket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::Locker::_shouldAcquireTicket = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaccad85edd0064fc9bc9373d5e412747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccad85edd0064fc9bc9373d5e412747">&#9670;&nbsp;</a></span>_shouldConflictWithSecondaryBatchApplication</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::Locker::_shouldConflictWithSecondaryBatchApplication = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e907d7c1a238d90330768e7444430f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e907d7c1a238d90330768e7444430f4">&#9670;&nbsp;</a></span>_uninterruptibleLocksRequested</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mongo::Locker::_uninterruptibleLocksRequested = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of callers that are guarding from lock interruptions. </p>
<p>When 0, all lock acquisitions are interruptible. When positive, no lock acquisitions are interruptible. This is only true for database and global locks. <a class="el" href="classmongo_1_1Collection.html" title="this is NOT safe through a yield right now. ">Collection</a> locks are never interruptible. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/louis/git/mongo/src/mongo/db/concurrency/<a class="el" href="locker_8h_source.html">locker.h</a></li>
<li>/home/louis/git/mongo/src/mongo/db/concurrency/<a class="el" href="lock__state_8cpp.html">lock_state.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemongo.html">mongo</a></li><li class="navelem"><a class="el" href="classmongo_1_1Locker.html">Locker</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
