<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Storage Engine API: mongo::HeapRecordStoreBtree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link href="mongodb.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="mongodb-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Storage Engine API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmongo_1_1HeapRecordStoreBtree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmongo_1_1HeapRecordStoreBtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mongo::HeapRecordStoreBtree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> that stores all data on the heap.  
 <a href="classmongo_1_1HeapRecordStoreBtree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="heap__record__store__btree_8h_source.html">heap_record_store_btree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mongo::HeapRecordStoreBtree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmongo_1_1HeapRecordStoreBtree.png" usemap="#mongo::HeapRecordStoreBtree_map" alt=""/>
  <map id="mongo::HeapRecordStoreBtree_map" name="mongo::HeapRecordStoreBtree_map">
<area href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ..." alt="mongo::RecordStore" shape="rect" coords="0,0,186,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> that stores all data on the heap. </p>
<p>This implementation contains only the functionality necessary to test btree. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmongo_1_1HeapRecordStoreBtree_1_1MmapV1RecordHeader.html">MmapV1RecordHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b93ce6400b7bd820a04c00e7a30139c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a9b93ce6400b7bd820a04c00e7a30139c">HeapRecordStoreBtree</a> (StringData <a class="el" href="classmongo_1_1RecordStore.html#ab57ca9998314c5c59f284515fd8bdea8">ns</a>)</td></tr>
<tr class="separator:a9b93ce6400b7bd820a04c00e7a30139c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af846e715e9f71ba85170cb58d4ef46a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmongo_1_1RecordData.html">RecordData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#af846e715e9f71ba85170cb58d4ef46a9">dataFor</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;loc) const</td></tr>
<tr class="memdesc:af846e715e9f71ba85170cb58d4ef46a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classmongo_1_1RecordData.html" title="A replacement for the Record class. ">RecordData</a> at loc, which must exist.  <a href="#af846e715e9f71ba85170cb58d4ef46a9">More...</a><br /></td></tr>
<tr class="separator:af846e715e9f71ba85170cb58d4ef46a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e4fc0d6a41f880b348441fda4ae71a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a64e4fc0d6a41f880b348441fda4ae71a">findRecord</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;loc, <a class="el" href="classmongo_1_1RecordData.html">RecordData</a> *out) const</td></tr>
<tr class="separator:a64e4fc0d6a41f880b348441fda4ae71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d4cb81e2e133c3237481a8f6162769"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a01d4cb81e2e133c3237481a8f6162769">deleteRecord</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;dl)</td></tr>
<tr class="separator:a01d4cb81e2e133c3237481a8f6162769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f373e01917221f449ff2422e3768c8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmongo_1_1StatusWith.html">StatusWith</a>&lt; RecordId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a6f373e01917221f449ff2422e3768c8a">insertRecord</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const char *<a class="el" href="ephemeral__for__test__record__store__test_8cpp.html#a7b0b6386ed9af4d133c80f6322cc60dc">data</a>, int len, Timestamp, bool enforceQuota)</td></tr>
<tr class="separator:a6f373e01917221f449ff2422e3768c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6262a3f62597d90ccf43daa2db56c0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ac6262a3f62597d90ccf43daa2db56c0e">insertRecordsWithDocWriter</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const <a class="el" href="classmongo_1_1DocWriter.html">DocWriter</a> *const *docs, const Timestamp *, size_t nDocs, RecordId *idsOut)</td></tr>
<tr class="memdesc:ac6262a3f62597d90ccf43daa2db56c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts nDocs documents into this <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> using the <a class="el" href="classmongo_1_1DocWriter.html" title="Allows inserting a Record &quot;in-place&quot; without creating a copy ahead of time. ">DocWriter</a> interface.  <a href="#ac6262a3f62597d90ccf43daa2db56c0e">More...</a><br /></td></tr>
<tr class="separator:ac6262a3f62597d90ccf43daa2db56c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f30fa91d06e00436401203e567a6025"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a9f30fa91d06e00436401203e567a6025">numRecords</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const</td></tr>
<tr class="memdesc:a9f30fa91d06e00436401203e567a6025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of record in the <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a>.  <a href="#a9f30fa91d06e00436401203e567a6025">More...</a><br /></td></tr>
<tr class="separator:a9f30fa91d06e00436401203e567a6025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8013b74da8bf200334d0cd29e170d71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ac8013b74da8bf200334d0cd29e170d71">touch</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, BSONObjBuilder *output) const</td></tr>
<tr class="memdesc:ac8013b74da8bf200334d0cd29e170d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all data into cache.  <a href="#ac8013b74da8bf200334d0cd29e170d71">More...</a><br /></td></tr>
<tr class="separator:ac8013b74da8bf200334d0cd29e170d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cb68af9083a941bb5520afbdd41034"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a46cb68af9083a941bb5520afbdd41034">updateRecord</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;oldLocation, const char *<a class="el" href="ephemeral__for__test__record__store__test_8cpp.html#a7b0b6386ed9af4d133c80f6322cc60dc">data</a>, int len, bool enforceQuota, <a class="el" href="classmongo_1_1UpdateNotifier.html">UpdateNotifier</a> *notifier)</td></tr>
<tr class="separator:a46cb68af9083a941bb5520afbdd41034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e5ce913c64a63ebf101b87290adf3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a6c0e5ce913c64a63ebf101b87290adf3">updateWithDamagesSupported</a> () const</td></tr>
<tr class="separator:a6c0e5ce913c64a63ebf101b87290adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93777ed5e7e6bccebc0e0e9dbabfdbab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmongo_1_1StatusWith.html">StatusWith</a>&lt; <a class="el" href="classmongo_1_1RecordData.html">RecordData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a93777ed5e7e6bccebc0e0e9dbabfdbab">updateWithDamages</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;loc, const <a class="el" href="classmongo_1_1RecordData.html">RecordData</a> &amp;oldRec, const char *damageSource, const mutablebson::DamageVector &amp;damages)</td></tr>
<tr class="memdesc:a93777ed5e7e6bccebc0e0e9dbabfdbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the record positioned at 'loc' in-place using the deltas described by 'damages'.  <a href="#a93777ed5e7e6bccebc0e0e9dbabfdbab">More...</a><br /></td></tr>
<tr class="separator:a93777ed5e7e6bccebc0e0e9dbabfdbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12567db713ae7a9aea4e35a3e8e0af7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmongo_1_1SeekableRecordCursor.html">SeekableRecordCursor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a12567db713ae7a9aea4e35a3e8e0af7b">getCursor</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, bool forward) const final</td></tr>
<tr class="memdesc:a12567db713ae7a9aea4e35a3e8e0af7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new cursor over this record store.  <a href="#a12567db713ae7a9aea4e35a3e8e0af7b">More...</a><br /></td></tr>
<tr class="separator:a12567db713ae7a9aea4e35a3e8e0af7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace98280b0264cfc077685c0c13776a31"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ace98280b0264cfc077685c0c13776a31">truncate</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>)</td></tr>
<tr class="memdesc:ace98280b0264cfc077685c0c13776a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all Records  <a href="#ace98280b0264cfc077685c0c13776a31">More...</a><br /></td></tr>
<tr class="separator:ace98280b0264cfc077685c0c13776a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fbe815d136a6e3165daa6c6b53322d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a58fbe815d136a6e3165daa6c6b53322d">cappedTruncateAfter</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, RecordId end, bool <a class="el" href="btree__interface_8cpp.html#a70a7fb264031a3a75f54886770610f78">inclusive</a>)</td></tr>
<tr class="memdesc:a58fbe815d136a6e3165daa6c6b53322d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate documents newer than the document at 'end' from the capped collection.  <a href="#a58fbe815d136a6e3165daa6c6b53322d">More...</a><br /></td></tr>
<tr class="separator:a58fbe815d136a6e3165daa6c6b53322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65c96ddfa71c54302369729b1325bfa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ad65c96ddfa71c54302369729b1325bfa">compactSupported</a> () const</td></tr>
<tr class="memdesc:ad65c96ddfa71c54302369729b1325bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">does this <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> support the compact operation?  <a href="#ad65c96ddfa71c54302369729b1325bfa">More...</a><br /></td></tr>
<tr class="separator:ad65c96ddfa71c54302369729b1325bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fbd07a6333884d478ceef4655711ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ab0fbd07a6333884d478ceef4655711ef">validate</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, <a class="el" href="namespacemongo.html#a7cc155634c5bc912468d33fe47041775">ValidateCmdLevel</a> level, <a class="el" href="classmongo_1_1ValidateAdaptor.html">ValidateAdaptor</a> *adaptor, <a class="el" href="structmongo_1_1ValidateResults.html">ValidateResults</a> *results, BSONObjBuilder *output)</td></tr>
<tr class="separator:ab0fbd07a6333884d478ceef4655711ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432493872f2fc29c58e527d8c05d5e8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a432493872f2fc29c58e527d8c05d5e8c">appendCustomStats</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, BSONObjBuilder *result, double scale) const</td></tr>
<tr class="separator:a432493872f2fc29c58e527d8c05d5e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab876d968e13db55da2f8004b0a125df9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ab876d968e13db55da2f8004b0a125df9">increaseStorageSize</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, int size, bool enforceQuota)</td></tr>
<tr class="separator:ab876d968e13db55da2f8004b0a125df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045d41186e66bd24552cb825308c285"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ab045d41186e66bd24552cb825308c285">storageSize</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, BSONObjBuilder *extraInfo=NULL, int infoLevel=0) const</td></tr>
<tr class="separator:ab045d41186e66bd24552cb825308c285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec4567ebdc9a3fea33f58efcfcc67aa"><td class="memItemLeft" align="right" valign="top">virtual long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#afec4567ebdc9a3fea33f58efcfcc67aa">dataSize</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const</td></tr>
<tr class="memdesc:afec4567ebdc9a3fea33f58efcfcc67aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataSize is an approximation of the sum of the sizes (in bytes) of the documents or entries in the recordStore.  <a href="#afec4567ebdc9a3fea33f58efcfcc67aa">More...</a><br /></td></tr>
<tr class="separator:afec4567ebdc9a3fea33f58efcfcc67aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10b9a5c19176f0a054619e411a7d023"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structmongo_1_1HeapRecordStoreBtree_1_1MmapV1RecordHeader.html">MmapV1RecordHeader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ab10b9a5c19176f0a054619e411a7d023">recordFor</a> (const RecordId &amp;loc) const</td></tr>
<tr class="separator:ab10b9a5c19176f0a054619e411a7d023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed101ffb822aa4efba7eb480326db1a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#aeed101ffb822aa4efba7eb480326db1a">isCapped</a> () const</td></tr>
<tr class="separator:aeed101ffb822aa4efba7eb480326db1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1fe799bfde2b5e0edd8eeb0e68422"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#aedd1fe799bfde2b5e0edd8eeb0e68422">name</a> () const</td></tr>
<tr class="separator:aedd1fe799bfde2b5e0edd8eeb0e68422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7fd2fd75733d6c22a61ed16c3fcf3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#ada7fd2fd75733d6c22a61ed16c3fcf3b">waitForAllEarlierOplogWritesToBeVisible</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const override</td></tr>
<tr class="memdesc:ada7fd2fd75733d6c22a61ed16c3fcf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all writes that completed before this call to be visible to forward scans.  <a href="#ada7fd2fd75733d6c22a61ed16c3fcf3b">More...</a><br /></td></tr>
<tr class="separator:ada7fd2fd75733d6c22a61ed16c3fcf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c8f20dceb95302862aece793b7a2e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a91c8f20dceb95302862aece793b7a2e0">updateStatsAfterRepair</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, long long <a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a9f30fa91d06e00436401203e567a6025">numRecords</a>, long long <a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#afec4567ebdc9a3fea33f58efcfcc67aa">dataSize</a>)</td></tr>
<tr class="memdesc:a91c8f20dceb95302862aece793b7a2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a repair operation is run with the recomputed numRecords and dataSize.  <a href="#a91c8f20dceb95302862aece793b7a2e0">More...</a><br /></td></tr>
<tr class="separator:a91c8f20dceb95302862aece793b7a2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmongo_1_1RecordStore"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmongo_1_1RecordStore')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmongo_1_1RecordStore.html">mongo::RecordStore</a></td></tr>
<tr class="memitem:a10c9d0781171d6885030398acb2d2a59 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a10c9d0781171d6885030398acb2d2a59">RecordStore</a> (StringData <a class="el" href="classmongo_1_1RecordStore.html#ab57ca9998314c5c59f284515fd8bdea8">ns</a>)</td></tr>
<tr class="separator:a10c9d0781171d6885030398acb2d2a59 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f0fd57480351bdc0986944f66ee300 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a15f0fd57480351bdc0986944f66ee300">~RecordStore</a> ()</td></tr>
<tr class="separator:a15f0fd57480351bdc0986944f66ee300 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57ca9998314c5c59f284515fd8bdea8 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#ab57ca9998314c5c59f284515fd8bdea8">ns</a> () const</td></tr>
<tr class="separator:ab57ca9998314c5c59f284515fd8bdea8 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0919c25270d91c3501d796e5178a0c8e inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a0919c25270d91c3501d796e5178a0c8e">setCappedCallback</a> (<a class="el" href="classmongo_1_1CappedCallback.html">CappedCallback</a> *)</td></tr>
<tr class="separator:a0919c25270d91c3501d796e5178a0c8e inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ed02de76406a5516d5a14f27dbf22 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a289ed02de76406a5516d5a14f27dbf22">insertRecords</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, std::vector&lt; <a class="el" href="structmongo_1_1Record.html">Record</a> &gt; *records, std::vector&lt; Timestamp &gt; *timestamps, bool enforceQuota)</td></tr>
<tr class="separator:a289ed02de76406a5516d5a14f27dbf22 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5f95b3596bb8b1d85c5a24c2a48fb6 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1StatusWith.html">StatusWith</a>&lt; RecordId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a8d5f95b3596bb8b1d85c5a24c2a48fb6">insertRecordWithDocWriter</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const <a class="el" href="classmongo_1_1DocWriter.html">DocWriter</a> *doc, Timestamp timestamp)</td></tr>
<tr class="memdesc:a8d5f95b3596bb8b1d85c5a24c2a48fb6 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin wrapper around <a class="el" href="classmongo_1_1RecordStore.html#a2cd3a7f097b6a0c8ae9036df1f4a1b03" title="Inserts nDocs documents into this RecordStore using the DocWriter interface. ">insertRecordsWithDocWriter()</a> to simplify handling of single DocWriters.  <a href="classmongo_1_1RecordStore.html#a8d5f95b3596bb8b1d85c5a24c2a48fb6">More...</a><br /></td></tr>
<tr class="separator:a8d5f95b3596bb8b1d85c5a24c2a48fb6 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa34ca87ea7e872232cfefb6bc809d3f inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classmongo_1_1RecordCursor.html">RecordCursor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#afa34ca87ea7e872232cfefb6bc809d3f">getCursorForRepair</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const</td></tr>
<tr class="memdesc:afa34ca87ea7e872232cfefb6bc809d3f inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a cursor over a potentially corrupted store, which can be used to salvage damaged records.  <a href="classmongo_1_1RecordStore.html#afa34ca87ea7e872232cfefb6bc809d3f">More...</a><br /></td></tr>
<tr class="separator:afa34ca87ea7e872232cfefb6bc809d3f inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044a55f90a381a3504d34139889a339c inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classmongo_1_1RecordCursor.html">RecordCursor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a044a55f90a381a3504d34139889a339c">getRandomCursor</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const</td></tr>
<tr class="memdesc:a044a55f90a381a3504d34139889a339c inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a cursor over a record store that returns documents in a randomized order, and allows storage engines to provide a more efficient way of random sampling of a record store than MongoDB's default sampling methods, which is used when this method returns {}.  <a href="classmongo_1_1RecordStore.html#a044a55f90a381a3504d34139889a339c">More...</a><br /></td></tr>
<tr class="separator:a044a55f90a381a3504d34139889a339c inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cd14207566be7a6fe132215ea4238b inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::unique_ptr&lt; <a class="el" href="classmongo_1_1RecordCursor.html">RecordCursor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a81cd14207566be7a6fe132215ea4238b">getManyCursors</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>) const</td></tr>
<tr class="memdesc:a81cd14207566be7a6fe132215ea4238b inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns many RecordCursors that partition the <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> into many disjoint sets.  <a href="classmongo_1_1RecordStore.html#a81cd14207566be7a6fe132215ea4238b">More...</a><br /></td></tr>
<tr class="separator:a81cd14207566be7a6fe132215ea4238b inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e22d1d3c67140ec14f52ed1c2bdc5d6 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a6e22d1d3c67140ec14f52ed1c2bdc5d6">compactsInPlace</a> () const</td></tr>
<tr class="memdesc:a6e22d1d3c67140ec14f52ed1c2bdc5d6 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <a class="el" href="classmongo_1_1RecordStore.html#a346acedb3f0b06954ab2deb83add6b38" title="Attempt to reduce the storage space used by this RecordStore. ">compact()</a> leave RecordIds alone or can they change.  <a href="classmongo_1_1RecordStore.html#a6e22d1d3c67140ec14f52ed1c2bdc5d6">More...</a><br /></td></tr>
<tr class="separator:a6e22d1d3c67140ec14f52ed1c2bdc5d6 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346acedb3f0b06954ab2deb83add6b38 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a346acedb3f0b06954ab2deb83add6b38">compact</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, <a class="el" href="classmongo_1_1RecordStoreCompactAdaptor.html">RecordStoreCompactAdaptor</a> *adaptor, const <a class="el" href="structmongo_1_1CompactOptions.html">CompactOptions</a> *<a class="el" href="namespacemongo.html#ad271b77bcd8d56d7a7e2205e9cb55df7">options</a>, <a class="el" href="structmongo_1_1CompactStats.html">CompactStats</a> *<a class="el" href="lock__state_8cpp.html#a462377416929733211c8a52a7de37ad9">stats</a>)</td></tr>
<tr class="memdesc:a346acedb3f0b06954ab2deb83add6b38 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reduce the storage space used by this <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a>.  <a href="classmongo_1_1RecordStore.html#a346acedb3f0b06954ab2deb83add6b38">More...</a><br /></td></tr>
<tr class="separator:a346acedb3f0b06954ab2deb83add6b38 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8985501aa36222d37ab2dd9b67707d7 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#ae8985501aa36222d37ab2dd9b67707d7">isInRecordIdOrder</a> () const</td></tr>
<tr class="memdesc:ae8985501aa36222d37ab2dd9b67707d7 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> cursor retrieve its document in RecordId Order?  <a href="classmongo_1_1RecordStore.html#ae8985501aa36222d37ab2dd9b67707d7">More...</a><br /></td></tr>
<tr class="separator:ae8985501aa36222d37ab2dd9b67707d7 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdb134cd28102ea5b25bb1e5da38209 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual boost::optional&lt; RecordId &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#accdb134cd28102ea5b25bb1e5da38209">oplogStartHack</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const RecordId &amp;startingPosition) const</td></tr>
<tr class="memdesc:accdb134cd28102ea5b25bb1e5da38209 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the RecordId of an oplog entry as close to startingPosition as possible without being higher.  <a href="classmongo_1_1RecordStore.html#accdb134cd28102ea5b25bb1e5da38209">More...</a><br /></td></tr>
<tr class="separator:accdb134cd28102ea5b25bb1e5da38209 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac034b0f4a1a4f9e8dbc3190262e209ff inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#ac034b0f4a1a4f9e8dbc3190262e209ff">oplogDiskLocRegister</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, const Timestamp &amp;opTime, bool orderedCommit)</td></tr>
<tr class="memdesc:ac034b0f4a1a4f9e8dbc3190262e209ff inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">When we write to an oplog, we call this so that if the storage engine supports doc locking, it can manage the visibility of oplog entries to ensure they are ordered.  <a href="classmongo_1_1RecordStore.html#ac034b0f4a1a4f9e8dbc3190262e209ff">More...</a><br /></td></tr>
<tr class="separator:ac034b0f4a1a4f9e8dbc3190262e209ff inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89264836634cbab1e2ea378c6bedcbc2 inherit pub_methods_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a89264836634cbab1e2ea378c6bedcbc2">updateCappedSize</a> (OperationContext *<a class="el" href="namespacemongo.html#a15b23ef1d9a7f6cdadbf866f1e8e5043">opCtx</a>, long long cappedSize)</td></tr>
<tr class="memdesc:a89264836634cbab1e2ea378c6bedcbc2 inherit pub_methods_classmongo_1_1RecordStore"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to support online change oplog size.  <a href="classmongo_1_1RecordStore.html#a89264836634cbab1e2ea378c6bedcbc2">More...</a><br /></td></tr>
<tr class="separator:a89264836634cbab1e2ea378c6bedcbc2 inherit pub_methods_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a3b9a1e052e083c156eb739330374c1f0"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; RecordId, <a class="el" href="structmongo_1_1HeapRecordStoreBtree_1_1MmapV1RecordHeader.html">HeapRecordStoreBtree::MmapV1RecordHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a3b9a1e052e083c156eb739330374c1f0">Records</a></td></tr>
<tr class="separator:a3b9a1e052e083c156eb739330374c1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0b263df31a5b9b9dfa1fe1486879dc78"><td class="memItemLeft" align="right" valign="top">RecordId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a0b263df31a5b9b9dfa1fe1486879dc78">allocateLoc</a> ()</td></tr>
<tr class="separator:a0b263df31a5b9b9dfa1fe1486879dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a467568ab741503bf1a1de457cdf5da69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a3b9a1e052e083c156eb739330374c1f0">Records</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a467568ab741503bf1a1de457cdf5da69">_records</a></td></tr>
<tr class="separator:a467568ab741503bf1a1de457cdf5da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef497b02c00bb27855695651562fe312"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#aef497b02c00bb27855695651562fe312">_nextId</a></td></tr>
<tr class="separator:aef497b02c00bb27855695651562fe312"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classmongo_1_1RecordStore"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmongo_1_1RecordStore')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmongo_1_1RecordStore.html">mongo::RecordStore</a></td></tr>
<tr class="memitem:a6a03f183b6b705e45a1e170a6bb5b6bc inherit pro_attribs_classmongo_1_1RecordStore"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmongo_1_1RecordStore.html#a6a03f183b6b705e45a1e170a6bb5b6bc">_ns</a></td></tr>
<tr class="separator:a6a03f183b6b705e45a1e170a6bb5b6bc inherit pro_attribs_classmongo_1_1RecordStore"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3b9a1e052e083c156eb739330374c1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9a1e052e083c156eb739330374c1f0">&#9670;&nbsp;</a></span>Records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;RecordId, <a class="el" href="structmongo_1_1HeapRecordStoreBtree_1_1MmapV1RecordHeader.html">HeapRecordStoreBtree::MmapV1RecordHeader</a>&gt; <a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a3b9a1e052e083c156eb739330374c1f0">mongo::HeapRecordStoreBtree::Records</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9b93ce6400b7bd820a04c00e7a30139c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93ce6400b7bd820a04c00e7a30139c">&#9670;&nbsp;</a></span>HeapRecordStoreBtree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mongo::HeapRecordStoreBtree::HeapRecordStoreBtree </td>
          <td>(</td>
          <td class="paramtype">StringData&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0b263df31a5b9b9dfa1fe1486879dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b263df31a5b9b9dfa1fe1486879dc78">&#9670;&nbsp;</a></span>allocateLoc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RecordId mongo::HeapRecordStoreBtree::allocateLoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a432493872f2fc29c58e527d8c05d5e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432493872f2fc29c58e527d8c05d5e8c">&#9670;&nbsp;</a></span>appendCustomStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::appendCustomStats </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSONObjBuilder *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleSize</td><td>- amount by which to scale size metrics appends any custom stats from the <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> or other unique stats </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a5cb48e63dd3762331aa2ed79dcfd5edb">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a58fbe815d136a6e3165daa6c6b53322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fbe815d136a6e3165daa6c6b53322d">&#9670;&nbsp;</a></span>cappedTruncateAfter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::cappedTruncateAfter </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordId&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate documents newer than the document at 'end' from the capped collection. </p>
<p>The collection cannot be completely emptied using this function. An assertion will be thrown if that is attempted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inclusive</td><td>- Truncate 'end' as well iff true </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#af94e47409108ed086b750b766ab6c54a">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ad65c96ddfa71c54302369729b1325bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65c96ddfa71c54302369729b1325bfa">&#9670;&nbsp;</a></span>compactSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::HeapRecordStoreBtree::compactSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>does this <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> support the compact operation? </p>
<p>If you return true, you must provide implementations of all compact methods. </p>

<p>Reimplemented from <a class="el" href="classmongo_1_1RecordStore.html#aa2e20bee4cc02cb9bf7233930d18b0ab">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="af846e715e9f71ba85170cb58d4ef46a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af846e715e9f71ba85170cb58d4ef46a9">&#9670;&nbsp;</a></span>dataFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1RecordData.html">RecordData</a> mongo::HeapRecordStoreBtree::dataFor </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classmongo_1_1RecordData.html" title="A replacement for the Record class. ">RecordData</a> at loc, which must exist. </p>
<p>If unowned data is returned, it is valid until the next modification of this <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> or the lock on this collection is released.</p>
<p>In general, prefer findRecord or RecordCursor::seekExact since they can tell you if a record has been removed. </p>

<p>Reimplemented from <a class="el" href="classmongo_1_1RecordStore.html#adee284dee4957dbe7eff17da80e01183">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="afec4567ebdc9a3fea33f58efcfcc67aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec4567ebdc9a3fea33f58efcfcc67aa">&#9670;&nbsp;</a></span>dataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long mongo::HeapRecordStoreBtree::dataSize </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dataSize is an approximation of the sum of the sizes (in bytes) of the documents or entries in the recordStore. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#af81322ff97471b16bfd172cd0020ec5b">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a01d4cb81e2e133c3237481a8f6162769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d4cb81e2e133c3237481a8f6162769">&#9670;&nbsp;</a></span>deleteRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::deleteRecord </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>dl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a88d00f49ffbbe8228dfd1b0bb7f093b3">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a64e4fc0d6a41f880b348441fda4ae71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e4fc0d6a41f880b348441fda4ae71a">&#9670;&nbsp;</a></span>findRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mongo::HeapRecordStoreBtree::findRecord </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmongo_1_1RecordData.html">RecordData</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>- If the record exists, the contents of this are set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there is a <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> for loc</dd></dl>
<p>If unowned data is returned, it is valid until the next modification of this <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> or the lock on this collection is released.</p>
<p>In general prefer RecordCursor::seekExact since it can avoid copying data in more storageEngines.</p>
<p>Warning: MMAPv1 cannot detect if RecordIds are valid. Therefore callers should only pass potentially deleted RecordIds to seek methods if they know that MMAPv1 is not the current storage engine. All new storage engines must support detecting the existence of Records. </p>

<p>Reimplemented from <a class="el" href="classmongo_1_1RecordStore.html#a881b5b4d85a8e6544160b0275cd47222">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a12567db713ae7a9aea4e35a3e8e0af7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12567db713ae7a9aea4e35a3e8e0af7b">&#9670;&nbsp;</a></span>getCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmongo_1_1SeekableRecordCursor.html">SeekableRecordCursor</a>&gt; mongo::HeapRecordStoreBtree::getCursor </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new cursor over this record store. </p>
<p>The cursor is logically positioned before the first (or last if !forward) <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> in the collection so that <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> will be returned on the first call to next(). Implementations are allowed to lazily seek to the first <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> when next() is called rather than doing it on construction. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a1088a44661d162d4ddcd7b12d9b0ca77">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ab876d968e13db55da2f8004b0a125df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab876d968e13db55da2f8004b0a125df9">&#9670;&nbsp;</a></span>increaseStorageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::increaseStorageSize </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforceQuota</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f373e01917221f449ff2422e3768c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f373e01917221f449ff2422e3768c8a">&#9670;&nbsp;</a></span>insertRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1StatusWith.html">StatusWith</a>&lt; RecordId &gt; mongo::HeapRecordStoreBtree::insertRecord </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Timestamp&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforceQuota</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#ae3c39aa6eedd361492038a4b4a0acc69">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ac6262a3f62597d90ccf43daa2db56c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6262a3f62597d90ccf43daa2db56c0e">&#9670;&nbsp;</a></span>insertRecordsWithDocWriter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a> mongo::HeapRecordStoreBtree::insertRecordsWithDocWriter </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1DocWriter.html">DocWriter</a> *const *&#160;</td>
          <td class="paramname"><em>docs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Timestamp *&#160;</td>
          <td class="paramname"><em>timestamps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordId *&#160;</td>
          <td class="paramname"><em>idsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts nDocs documents into this <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a> using the <a class="el" href="classmongo_1_1DocWriter.html" title="Allows inserting a Record &quot;in-place&quot; without creating a copy ahead of time. ">DocWriter</a> interface. </p>
<p>This allows the storage engine to reserve space for a record and have it built in-place rather than building the record then copying it into its destination.</p>
<p>On success, if idsOut is non-null the RecordIds of the inserted records will be written into it. It must have space for nDocs RecordIds. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a2cd3a7f097b6a0c8ae9036df1f4a1b03">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="aeed101ffb822aa4efba7eb480326db1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed101ffb822aa4efba7eb480326db1a">&#9670;&nbsp;</a></span>isCapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::HeapRecordStoreBtree::isCapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a3f586a7df2a8ce13061f12311e8fcf47">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="aedd1fe799bfde2b5e0edd8eeb0e68422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1fe799bfde2b5e0edd8eeb0e68422">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mongo::HeapRecordStoreBtree::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a3add80715366bb26bcf8afdca47261b3">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a9f30fa91d06e00436401203e567a6025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f30fa91d06e00436401203e567a6025">&#9670;&nbsp;</a></span>numRecords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long long mongo::HeapRecordStoreBtree::numRecords </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of record in the <a class="el" href="classmongo_1_1RecordStore.html" title="An abstraction used for storing documents in a collection or entries in an index. ...">RecordStore</a>. </p>
<p>You may need to cache it, so this call takes constant time, as it is called often. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a6ce1ace33ef4a63bb681ec4cab82bddd">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ab10b9a5c19176f0a054619e411a7d023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10b9a5c19176f0a054619e411a7d023">&#9670;&nbsp;</a></span>recordFor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structmongo_1_1HeapRecordStoreBtree_1_1MmapV1RecordHeader.html">MmapV1RecordHeader</a>* mongo::HeapRecordStoreBtree::recordFor </td>
          <td>(</td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab045d41186e66bd24552cb825308c285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab045d41186e66bd24552cb825308c285">&#9670;&nbsp;</a></span>storageSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t mongo::HeapRecordStoreBtree::storageSize </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSONObjBuilder *&#160;</td>
          <td class="paramname"><em>extraInfo</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>infoLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraInfo</td><td>- optional more debug info </td></tr>
    <tr><td class="paramname">level</td><td>- optional, level of debug info to put in (higher is more) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total estimate size (in bytes) on stable storage </dd></dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#aa70dc26fa382ed42d86b47c4419739df">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ac8013b74da8bf200334d0cd29e170d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8013b74da8bf200334d0cd29e170d71">&#9670;&nbsp;</a></span>touch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a> mongo::HeapRecordStoreBtree::touch </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSONObjBuilder *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load all data into cache. </p>
<p>What cache depends on implementation.</p>
<p>If the underlying storage engine does not support the operation, returns ErrorCodes::CommandNotSupported</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>(optional) - where to put detailed stats </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classmongo_1_1RecordStore.html#aff413136bf8d0191d90fbf91f9db5072">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ace98280b0264cfc077685c0c13776a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace98280b0264cfc077685c0c13776a31">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a> mongo::HeapRecordStoreBtree::truncate </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes all Records </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a64860d998ce26a69c8571dd02ec2a5b8">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a46cb68af9083a941bb5520afbdd41034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cb68af9083a941bb5520afbdd41034">&#9670;&nbsp;</a></span>updateRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a> mongo::HeapRecordStoreBtree::updateRecord </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>oldLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enforceQuota</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmongo_1_1UpdateNotifier.html">UpdateNotifier</a> *&#160;</td>
          <td class="paramname"><em>notifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notifier</td><td>- Only used by record stores which do not support doc-locking. Called only in the case of an in-place update. Called just before the in-place write occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status - If a document move is required (MMAPv1 only) then a status of ErrorCodes::NeedsDocumentMove will be returned. On receipt of this status no update will be performed. It is the caller's responsibility to:<ol type="1">
<li>Remove the existing document and associated index keys.</li>
<li>Insert a new document and index keys.</li>
</ol>
</dd></dl>
<p>For capped record stores, the record size will never change. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#ab11ecd3a04a7f5909e8943c8b51985c9">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a91c8f20dceb95302862aece793b7a2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c8f20dceb95302862aece793b7a2e0">&#9670;&nbsp;</a></span>updateStatsAfterRepair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::updateStatsAfterRepair </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>numRecords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a repair operation is run with the recomputed numRecords and dataSize. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a4ba5527ab658ec57fbd2b80554bdcf4a">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a93777ed5e7e6bccebc0e0e9dbabfdbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93777ed5e7e6bccebc0e0e9dbabfdbab">&#9670;&nbsp;</a></span>updateWithDamages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmongo_1_1StatusWith.html">StatusWith</a>&lt;<a class="el" href="classmongo_1_1RecordData.html">RecordData</a>&gt; mongo::HeapRecordStoreBtree::updateWithDamages </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordId &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmongo_1_1RecordData.html">RecordData</a> &amp;&#160;</td>
          <td class="paramname"><em>oldRec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>damageSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mutablebson::DamageVector &amp;&#160;</td>
          <td class="paramname"><em>damages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the record positioned at 'loc' in-place using the deltas described by 'damages'. </p>
<p>The 'damages' vector describes contiguous ranges of 'damageSource' from which to copy and apply byte-level changes to the data.</p>
<dl class="section return"><dt>Returns</dt><dd>the updated version of the record. If unowned data is returned, then it is valid until the next modification of this <a class="el" href="structmongo_1_1Record.html" title="The data items stored in a RecordStore. ">Record</a> or the lock on the collection has been released. </dd></dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#ad15415ccbf70b1d4dade0fc543416967">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="a6c0e5ce913c64a63ebf101b87290adf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0e5ce913c64a63ebf101b87290adf3">&#9670;&nbsp;</a></span>updateWithDamagesSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mongo::HeapRecordStoreBtree::updateWithDamagesSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns 'false' if this record store does not implement 'updatewithDamages'. If this method returns false, 'updateWithDamages' must not be called, and all updates must be routed through 'updateRecord' above. This allows the update framework to avoid doing the work of damage tracking if the underlying record store cannot utilize that information. </dd></dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a01fa74c96c2440e87ca4a17cb1dab136">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ab0fbd07a6333884d478ceef4655711ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fbd07a6333884d478ceef4655711ef">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemongo.html#a7dd53a44ec884164bc07ed073e9f31da">Status</a> mongo::HeapRecordStoreBtree::validate </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemongo.html#a7cc155634c5bc912468d33fe47041775">ValidateCmdLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmongo_1_1ValidateAdaptor.html">ValidateAdaptor</a> *&#160;</td>
          <td class="paramname"><em>adaptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmongo_1_1ValidateResults.html">ValidateResults</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSONObjBuilder *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>OK if the validate run successfully OK will be returned even if corruption is found deatils will be in result </dd></dl>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a7248338de6378676a2a1cbd1f38dab48">mongo::RecordStore</a>.</p>

</div>
</div>
<a id="ada7fd2fd75733d6c22a61ed16c3fcf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7fd2fd75733d6c22a61ed16c3fcf3b">&#9670;&nbsp;</a></span>waitForAllEarlierOplogWritesToBeVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemongo.html#aa639063deea016a1dac8f046e93900a6">void</a> mongo::HeapRecordStoreBtree::waitForAllEarlierOplogWritesToBeVisible </td>
          <td>(</td>
          <td class="paramtype">OperationContext *&#160;</td>
          <td class="paramname"><em>opCtx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for all writes that completed before this call to be visible to forward scans. </p>
<p>See the comment on <a class="el" href="classmongo_1_1RecordCursor.html" title="Retrieves Records from a RecordStore. ">RecordCursor</a> for more details about the visibility rules.</p>
<p>It is only legal to call this on an oplog. It is illegal to call this inside a <a class="el" href="classmongo_1_1WriteUnitOfWork.html" title="The WriteUnitOfWork is an RAII type that begins a storage engine write unit of work on both the Locke...">WriteUnitOfWork</a>. </p>

<p>Implements <a class="el" href="classmongo_1_1RecordStore.html#a7486ead4beef7feb9448d317261e36ee">mongo::RecordStore</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aef497b02c00bb27855695651562fe312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef497b02c00bb27855695651562fe312">&#9670;&nbsp;</a></span>_nextId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mongo::HeapRecordStoreBtree::_nextId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a467568ab741503bf1a1de457cdf5da69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467568ab741503bf1a1de457cdf5da69">&#9670;&nbsp;</a></span>_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html#a3b9a1e052e083c156eb739330374c1f0">Records</a> mongo::HeapRecordStoreBtree::_records</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/louis/git/mongodbsource.github.io/src/src/mongo/db/storage/mmap_v1/<a class="el" href="heap__record__store__btree_8h_source.html">heap_record_store_btree.h</a></li>
<li>/home/louis/git/mongodbsource.github.io/src/src/mongo/db/storage/mmap_v1/<a class="el" href="heap__record__store__btree_8cpp.html">heap_record_store_btree.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemongo.html">mongo</a></li><li class="navelem"><a class="el" href="classmongo_1_1HeapRecordStoreBtree.html">HeapRecordStoreBtree</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
